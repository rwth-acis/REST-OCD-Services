package i5.las2peer.services.ocd.graphs;

import com.arangodb.ArangoCollection;
import com.arangodb.ArangoDatabase;
import com.arangodb.entity.BaseDocument;
import com.arangodb.model.DocumentCreateOptions;
import com.arangodb.model.DocumentReadOptions;
import com.arangodb.model.DocumentUpdateOptions;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import i5.las2peer.services.ocd.algorithms.utils.OcdAlgorithmException;
import i5.las2peer.services.ocd.utils.Database;
import i5.las2peer.services.ocd.utils.ExecutionStatus;
import net.minidev.json.JSONObject;
import org.apache.commons.lang3.time.DateUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.ImmutableTriple;
import org.graphstream.graph.Node;
import org.la4j.matrix.Matrix;

import java.text.ParseException;
import java.time.Instant;
import java.util.Map.Entry;
import java.util.*;

/**
 * Represents a graph sequence (or dynamic graph), i.e. a (time-)ordered list of graphs
 *
 * @author Max Ki√ügen
 *
 */
//TODO: Check how/if graphs can be part of multiple sequences
//TODO: Check if date attributes are even needed here anymore
public class GraphSequence {

    public static final String collectionName = "customgraphsequence";
    public static final String customGraphKeysColumnName = "CUSTOM_GRAPH_KEYS";
    public static final String sequenceCommunityColorMapColumnName = "SEQ_COMM_COLOR_MAP";
    public static final String communitySequenceCommunityMapColumnName = "COMM_SEQ_COMM_MAP";
    public static final String timeOrderedColumnName = "TIME_ORDERED";
    public static final String extraInfoColumnName = "EXTRA_INFO";

    public static final String startDateColumnName = "START_DATE";
    public static final String endDateColumnName = "END_DATE";


    /**
     * System generated persistence key.
     */
    private String key;

    private List<String> customGraphKeys = new ArrayList<>();

    //TODO: Update SequenceCommunities when Cover/Graph are deleted.
    private HashMap<String,Integer> sequenceCommunityColorMap = null;
    private HashMap<String,String> communitySequenceCommunityMap = null;

    private boolean timeOrdered = false; //Variable to signify whether this sequence is time ordered  or not(i.e. when it was generated by a User that didnt take dates into account
    private JSONObject extraInfo = new JSONObject();
    private Date startDate = new Date(Long.MIN_VALUE);
    private Date endDate = new Date(Long.MAX_VALUE);

    private GraphSequence() {};

    public GraphSequence(String firstCGkey) {
        customGraphKeys.add(firstCGkey);
    }

    //TODO: Remove Sequence Community if empty?
    public void deleteGraphFromSequence(String graphKey, List<Cover> coverList) {
        customGraphKeys.remove(graphKey);
        if (communitySequenceCommunityMap != null) {
            for (Cover cover : coverList) {
                deleteCoverFromSequence(cover);
            }
        }
    }

    public void deleteCoverFromSequence(Cover cover) {
        if (communitySequenceCommunityMap != null) {
            for (Community comm : cover.getCommunities()) {
                String sequenceCommKey = communitySequenceCommunityMap.get(comm.getKey());
                communitySequenceCommunityMap.remove(comm.getKey());
                if(!communitySequenceCommunityMap.containsValue(sequenceCommKey)) { //TODO: Check if this can be done more nicely without adding too much more to the database
                    sequenceCommunityColorMap.remove(sequenceCommKey);
                }
            }
        }
    }

    //TODO: Make this a binary Search. Should for the moment not impact performance too much though, fetched docs are small and likely not many
    public boolean tryAddGraph (ArangoDatabase db, CustomGraph graph) throws OcdPersistenceLoadException {//, String newGraphKey, Date newGraphStartDate, Date newGraphEndDate) throws OcdPersistenceLoadException {
        if (this.timeOrdered) { //Can't add a graph to a sequence that (potentially) doesn't operate by our timeframe rules
            return false;
        }

        Date newGraphStartDate, newGraphEndDate;
        if(!graph.getExtraInfo().containsKey("startDate") || !graph.getExtraInfo().containsKey("endDate")) {//When dates dont exist then we cant put the graph into an ordered series
            return false;
        }
        try {
            newGraphStartDate = DateUtils.parseDate((String)graph.getExtraInfo().get("startDate"),"YYYY-MM-DD'T'HH:MM:SS.SSS'Z'", "YYYY-MM-DD'T'HH:MM:SS'Z'", "YYYY-MM-DD'Z'", "YYYY-MM-DD'T'HH:MM:SS.SSS", "YYYY-MM-DD'T'HH:MM:SS", "YYYY-MM-DD");
            newGraphEndDate = DateUtils.parseDate((String)graph.getExtraInfo().get("endDate"),"YYYY-MM-DD'T'HH:MM:SS.SSS'Z'", "YYYY-MM-DD'T'HH:MM:SS'Z'", "YYYY-MM-DD'Z'", "YYYY-MM-DD'T'HH:MM:SS.SSS", "YYYY-MM-DD'T'HH:MM:SS", "YYYY-MM-DD");
        }
        catch (ParseException e) { //TODO: Maybe throw an actual error here since that would mean a malformed date?
            return false;
        }

        ArangoCollection graphCollection = db.collection(CustomGraph.collectionName);

        // We are not checking whether the needed extraInfo attributes exist here since if they didn't the sequence would not be time ordered
        for (int i=0; i<customGraphKeys.size(); i++) {
            String seqGraphKey = customGraphKeys.get(i);
            ObjectNode seqGraphDoc = graphCollection.getDocument(seqGraphKey, ObjectNode.class);
            Date seqGraphStartDate = new Date(Long.MIN_VALUE);
            Date seqGraphEndDate = new Date(Long.MAX_VALUE);
            try {
                seqGraphStartDate = DateUtils.parseDate(seqGraphDoc.get(CustomGraph.extraInfoColumnName).get("startDate").toString(), "YYYY-MM-DD'T'HH:MM:SS.SSS'Z'", "YYYY-MM-DD'T'HH:MM:SS'Z'", "YYYY-MM-DD'Z'", "YYYY-MM-DD'T'HH:MM:SS.SSS", "YYYY-MM-DD'T'HH:MM:SS", "YYYY-MM-DD");
            }
            catch (ParseException ignored) {} // Just means that it will stay the initial value
            try {
                seqGraphEndDate = DateUtils.parseDate(seqGraphDoc.get(CustomGraph.extraInfoColumnName).get("endDate").toString(), "YYYY-MM-DD'T'HH:MM:SS.SSS'Z'", "YYYY-MM-DD'T'HH:MM:SS'Z'", "YYYY-MM-DD'Z'", "YYYY-MM-DD'T'HH:MM:SS.SSS", "YYYY-MM-DD'T'HH:MM:SS", "YYYY-MM-DD");
            }
            catch (ParseException ignored) {} // Just means that it will stay the initial value

            if (newGraphEndDate.getTime() <= seqGraphStartDate.getTime()) {
                if (i == 0) {
                    customGraphKeys.add(0,graph.getKey());
                    this.startDate = newGraphStartDate;
                    return true;
                }
                else {
                    ObjectNode nextGraphInListDoc = graphCollection.getDocument(customGraphKeys.get(i-1), ObjectNode.class);
                    Date seqPrevGraphEndDate;
                    try {
                        seqPrevGraphEndDate = DateUtils.parseDate(nextGraphInListDoc.get(CustomGraph.extraInfoColumnName).get("endDate").toString(), "YYYY-MM-DD'T'HH:MM:SS.SSS'Z'", "YYYY-MM-DD'T'HH:MM:SS'Z'", "YYYY-MM-DD'Z'", "YYYY-MM-DD'T'HH:MM:SS.SSS", "YYYY-MM-DD'T'HH:MM:SS", "YYYY-MM-DD");
                    }
                    catch (ParseException e) {
                        throw new OcdPersistenceLoadException("Could not retrieve start date for non-first graph in sequence");
                    }
                    if (newGraphStartDate.getTime() >= seqPrevGraphEndDate.getTime()) { // Check if we actually fit in between
                        customGraphKeys.add(i,graph.getKey());
                        return true;
                    }
                    break; // graph doesn't fit in sequence so we can abort
                }
            }
            else if (i == customGraphKeys.size()-1 && seqGraphEndDate != null && newGraphStartDate.getTime() >= seqGraphEndDate.getTime()) {
                customGraphKeys.add(graph.getKey());
                this.endDate = newGraphEndDate;
                return true;
            }
        }

        return false;
    }

    //TODO: Check performance of this
    private double getCommunitySimilarity(Community commA, Community commB) {
        double similarity = 0.0;
        CustomGraph commAGraph = commA.getCover().getGraph();
        for (Entry<Node,Double> entryB : commB.getMemberships().entrySet()) {
            if(commAGraph.getCustomNode(entryB.getKey()) != null) { // If the graph even has a similar node
                Node nodeA = commAGraph.getNode(commAGraph.getCustomNode(entryB.getKey()));
                //Belonging factor is 0 if node is not in the community
                similarity += 1 - Math.abs(commA.getBelongingFactor(nodeA) - entryB.getValue()); //TODO: Test if this similarity seems reasonable
            }
            else {
                similarity += 0.0; // If a node from the second graph doesn't exist in the first then it has no similarity
            }
        }
        return similarity/commB.getSize();
    }

    private <T> int getInsertionIndex(double similarityValue, ArrayList<ImmutableTriple<Double,T,T>> communitySimilarities) {
        if (communitySimilarities.size() == 0) {
            return 0;
        }
        else {
            int lowerBound = 0, upperBound = communitySimilarities.size()-1;
            while (lowerBound <= upperBound) {
                int listIndex = lowerBound  + ((upperBound - lowerBound) / 2);
                if(communitySimilarities.get(listIndex).getLeft() > similarityValue) {
                    upperBound = listIndex-1;
                }
                else if (communitySimilarities.get(listIndex).getLeft() < similarityValue) {
                    lowerBound = listIndex+1;
                }
                if (lowerBound == upperBound) {
                    return lowerBound+1;
                }
            }
        }
        return -1; //Should not happen
    }

    //What to do when a graph has no covers. Abort sequence comm generation? -> Still do but without and cope with that in SequenceVisualOutput
    //TODO: Optionally have a boolean to only generate new from point a new graph was added onward. But then the graphs index in the sequence needs to be known and maintained. Also after assignment unused sequenceCommunities need to be deleted from the map
    //TODO: Somehow do this without using a db and username attribute. Currently needed to just query on demand and not get passed a giant list of covers which in turn give all related graphs
    /**
     * Fills the sequence community maps
     * @param username the username for the graphs/communities
     * @param db the database used to fetch the graphs/communities
     * @param similarityThreshold a threshold of similarity between communities. If the similarity is below that, a new sequence community will be created
     * @throws OcdPersistenceLoadException if (one of) the graphs/communities can't be loaded
     */
    public void generateSequenceCommunities(String username, Database db, double similarityThreshold) throws OcdPersistenceLoadException {
        List<CoverMeta> coverMetas = new ArrayList<>();
        List<Integer> executionStatusIds = List.of(ExecutionStatus.COMPLETED.getId());
        List<Integer> metricExecutionStatusIds = List.of(ExecutionStatus.COMPLETED.getId(),ExecutionStatus.ERROR.getId(),ExecutionStatus.RUNNING.getId(),ExecutionStatus.WAITING.getId());

        for(String graphKey : customGraphKeys) {
            coverMetas.addAll(db.getCoverMetaDataEfficiently(username,graphKey,executionStatusIds,metricExecutionStatusIds,0,Integer.MAX_VALUE));
        }
        if (coverMetas.size() == 0) {
            throw new RuntimeException("Cant visualize sequence cause no covers exist");
        }

        sequenceCommunityColorMap = new HashMap<String,Integer>();
        communitySequenceCommunityMap = new HashMap<String,String>();
        int sequenceCoverCounter = 0;
        for (int i=0; i<coverMetas.size(); i++) {
            if(i == 0) { //Simply add the first communities of the first cover as sequence communities
                Cover firstCover = db.getCover(username, coverMetas.get(i).getGraphKey(), coverMetas.get(i).getKey());
                for(Community comm : firstCover.getCommunities()) {
                    sequenceCommunityColorMap.put(Integer.toString(sequenceCoverCounter),null); //TODO: Decide about color attribute, do I even need this?
                    communitySequenceCommunityMap.put(comm.getKey(),Integer.toString(sequenceCoverCounter));
                    sequenceCoverCounter++;
                }
            }
            else {
                ArrayList<ImmutableTriple<Double,String,String>> communitySimilarities = new ArrayList<>(); //Maps current communities to lists of the similarity values of the previous ones (ordered by similarity value)
                Cover prevCover = db.getCover(username, coverMetas.get(i-1).getGraphKey(), coverMetas.get(i).getKey());
                Cover currCover = db.getCover(username, coverMetas.get(i).getGraphKey(), coverMetas.get(i).getKey());

                //Compute Similarities for Communities of the two covers and insert them into an ordered list
                for(Community currComm : currCover.getCommunities()) {
                    for(Community prevComm : prevCover.getCommunities()) {
                        double commSimilarity = getCommunitySimilarity(prevComm,currComm);
                        int insertionIndex = getInsertionIndex(commSimilarity, communitySimilarities);
                        communitySimilarities.add(insertionIndex, new ImmutableTriple<>(commSimilarity, currComm.getKey(), prevComm.getKey()));
                    }
                }

                HashSet<String> usedCommunities = new HashSet<>();
                //Add most similar pairs to the sequenceCommunitMaps or create a new sequence community if we cant find a good available matching above the similarity threshold.
                for (ImmutableTriple<Double,String,String> similarityTriple : communitySimilarities) {
                    if(!usedCommunities.contains(similarityTriple.getRight())) { //I.e. if we didnt already map a community of the current cover to one of the previous
                        if(!usedCommunities.contains(similarityTriple.getMiddle())) { //I.e. if the community of the current cover wasn't already mapped
                            if(similarityTriple.getLeft() <= similarityThreshold) {
                                sequenceCommunityColorMap.put(Integer.toString(sequenceCoverCounter),null);
                                communitySequenceCommunityMap.put(similarityTriple.getMiddle(), Integer.toString(sequenceCoverCounter));
                                sequenceCoverCounter++;
                                usedCommunities.add(similarityTriple.getMiddle());
                            }
                            else {
                                communitySequenceCommunityMap.put(similarityTriple.getMiddle(), communitySequenceCommunityMap.get(similarityTriple.getRight()));
                                usedCommunities.add(similarityTriple.getMiddle());
                                usedCommunities.add(similarityTriple.getRight());
                            }
                        }
                        else {
                            similarityTriple = null; //TODO: Think of a more elegant way to do this
                        }
                    }
                    else {
                        similarityTriple = null; //TODO: Think of a more elegant way to do this
                    }
                }
                //Now create new sequenceCommunities for those that didn't get a mapping
                for(Community currComm : currCover.getCommunities()) {
                    if(!usedCommunities.contains(currComm.getKey())) {
                        sequenceCommunityColorMap.put(Integer.toString(sequenceCoverCounter),null);
                        communitySequenceCommunityMap.put(currComm.getKey(), Integer.toString(sequenceCoverCounter));
                        sequenceCoverCounter++;
                        //usedCommunities.add(currComm.getKey());
                    }
                }
            }
        }
    }

    public void persist(ArangoDatabase db, String transId) {
        ArangoCollection collection = db.collection(collectionName);
        BaseDocument bd = new BaseDocument();
        //options for the transaction
        DocumentCreateOptions createOptions = new DocumentCreateOptions().streamTransactionId(transId);
        DocumentUpdateOptions updateOptions = new DocumentUpdateOptions().streamTransactionId(transId);
        bd.addAttribute(timeOrderedColumnName, this.timeOrdered);
        bd.addAttribute(customGraphKeysColumnName, this.customGraphKeys);
        if (this.sequenceCommunityColorMap != null) { // If one is null, the other is too
            bd.addAttribute(sequenceCommunityColorMapColumnName, this.sequenceCommunityColorMap);
            bd.addAttribute(communitySequenceCommunityMapColumnName, this.communitySequenceCommunityMap);
        }
        bd.addAttribute(startDateColumnName, this.startDate != null ? this.startDate.toInstant() : null);
        bd.addAttribute(endDateColumnName, this.endDate != null ? this.endDate.toInstant() : null);
        bd.addAttribute(extraInfoColumnName,this.extraInfo);
        collection.insertDocument(bd, createOptions);
        this.key = bd.getKey();

        bd = new BaseDocument();

        collection.updateDocument(this.key, bd, updateOptions);
    }

    public static GraphSequence load(String key, ArangoDatabase db, String transId) throws OcdPersistenceLoadException {
        GraphSequence sq = new GraphSequence();
        ArangoCollection collection = db.collection(collectionName);

        DocumentReadOptions readOpt = new DocumentReadOptions().streamTransactionId(transId);
        BaseDocument bd = collection.getDocument(key, BaseDocument.class, readOpt);
        if (bd != null) {
            ObjectMapper om = new ObjectMapper();

            sq.key = key;
            sq.timeOrdered = om.convertValue(bd.getAttribute(timeOrderedColumnName), Boolean.class);
            sq.customGraphKeys = om.convertValue(bd.getAttribute(customGraphKeysColumnName), ArrayList.class);
            if(bd.getAttribute(sequenceCommunityColorMapColumnName) != null) { //TODO: Test this
                try {
                    sq.sequenceCommunityColorMap = om.convertValue(bd.getAttribute(sequenceCommunityColorMapColumnName), HashMap.class);
                    sq.communitySequenceCommunityMap = om.convertValue(bd.getAttribute(communitySequenceCommunityMapColumnName), HashMap.class);
                }
                catch (Exception e) {
                    throw new OcdPersistenceLoadException("Could not lode sequence community maps: " + e.getMessage());
                }
            }
            try {
                sq.startDate = DateUtils.parseDate(bd.getAttribute(startDateColumnName).toString(), "YYYY-MM-DD'T'HH:MM:SS.SSS'Z'", "YYYY-MM-DD'T'HH:MM:SS'Z'", "YYYY-MM-DD'Z'", "YYYY-MM-DD'T'HH:MM:SS.SSS", "YYYY-MM-DD'T'HH:MM:SS", "YYYY-MM-DD");
            }
            catch (ParseException e) {
                sq.startDate = new Date(Long.MIN_VALUE);
            }
            try {
                sq.endDate = DateUtils.parseDate(bd.getAttribute(endDateColumnName).toString(), "YYYY-MM-DD'T'HH:MM:SS.SSS'Z'", "YYYY-MM-DD'T'HH:MM:SS'Z'", "YYYY-MM-DD'Z'", "YYYY-MM-DD'T'HH:MM:SS.SSS", "YYYY-MM-DD'T'HH:MM:SS", "YYYY-MM-DD");
            }
            catch (ParseException e) {
                sq.endDate = new Date(Long.MAX_VALUE);
            }
            if(bd.getAttribute(extraInfoColumnName) != null){
                try {
                    sq.extraInfo = new JSONObject(om.convertValue(bd.getAttribute(extraInfoColumnName), Map.class));
                }
                catch (Exception e) {
                    throw new OcdPersistenceLoadException("Could not parse extraInfo of GraphSequence. " + e.getMessage());
                }
            }
            else {
                sq.extraInfo = new JSONObject();
            }
        }
        else {
            throw new OcdPersistenceLoadException("Could not find graph sequence");
        }
        return sq;
    }

    public void setStartDate(Date startDate) {
        this.startDate = startDate;
    }

    public void setEndDate(Date endDate) {
        this.endDate = endDate;
    }

    public Date getStartDate() {
        return startDate;
    }

    public Date getEndDate() {
        return endDate;
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public List<String> getCustomGraphKeys() {
        return customGraphKeys;
    }

    public void setCustomGraphKeys(List<String> customGraphKeys) {
        this.customGraphKeys = customGraphKeys;
    }

    public boolean isTimeOrdered() {
        return timeOrdered;
    }

    public void setTimeOrdered(boolean timeOrdered) {
        this.timeOrdered = timeOrdered;
    }

    public JSONObject getExtraInfo() {
        return extraInfo;
    }

    public void setExtraInfo(JSONObject extraInfo) {
        this.extraInfo = extraInfo;
    }

    public HashMap<String, Integer> getSequenceCommunityColorMap() {
        return sequenceCommunityColorMap;
    }

    public void setSequenceCommunityColorMap(HashMap<String, Integer> sequenceCommunityColorMap) {
        this.sequenceCommunityColorMap = sequenceCommunityColorMap;
    }

    public HashMap<String, String> getCommunitySequenceCommunityMap() {
        return communitySequenceCommunityMap;
    }

    public void setCommunitySequenceCommunityMap(HashMap<String, String> communitySequenceCommunityMap) {
        this.communitySequenceCommunityMap = communitySequenceCommunityMap;
    }
}
